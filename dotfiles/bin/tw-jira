#!/usr/bin/env python3
import argparse
import base64
from datetime import datetime, UTC
import json
import os
import re
import subprocess
import sys
import typing
import urllib.parse
import urllib.request

# UDAs
JIRA_KEY = "jira"
JIRA_STATUS = "jirastatus"
JIRA_PRIORITY = "jirapriority"
JIRA_PARENT = "jiraparent"

TW_DATE_FORMAT = "%Y-%m-%dT%H:%M:%SZ"

class Issue:
    def __init__(self, json: dict):
        self.json = json
        self.tw_json = None

    def __repr__(self):
        return f'<Issue {self.key}>'

    @property
    def key(self) -> str:
        return self.json["key"]

    @property
    def fields(self) -> dict:
        return self.json["fields"]

    @property
    def status(self) -> str:
        return self.fields["status"]["name"]

    @property
    def priority(self) -> str:
        return self.fields["priority"]["name"]

    @property
    def summary(self) -> str:
        return self.fields["summary"]

    @property
    def parent(self) -> typing.Optional['Issue']:
        if "parent" in self.fields and self.fields["parent"]:
            return Issue(self.fields["parent"])
        else:
            return None

    @property
    def issue_type(self) -> str:
        return self.fields["issuetype"]["name"]

    @property
    def created(self) -> str:
        return datetime.fromisoformat(self.fields["created"]).replace(microsecond=0, tzinfo=None).strftime(TW_DATE_FORMAT)

    def to_task_json(self) -> dict:
        out = {
            "description": f"{self.key}: {self.summary}",
            JIRA_KEY: self.key,
            JIRA_STATUS: self.status.replace(" ", "-").lower(),
            JIRA_PRIORITY: self.priority.replace(" ", "-").lower(),
            "entry": self.created,
        }

        if self.parent:
            out[JIRA_PARENT] = self.parent.key

        return out

    def changes_from_existing_task(self) -> typing.List[str]:
        if not self.tw_json:
            raise Exception("cannot diff with nothing! Create the tasks first.")

        mods = []

        for (key, value) in self.to_task_json().items():
            if key == "entry":
                comp = datetime.strptime(self.tw_json[key], "%Y%m%dT%H%M%SZ").strftime(TW_DATE_FORMAT)
                if value != comp:
                    mods.append(f"{key}:{value}")

            elif key not in self.tw_json or self.tw_json[key] != value:
                if key == "description":
                    mods.append(value)
                else:
                    mods.append(f"{key}:{value}")

        # we currently just assume that all tasks in Jira are pending (and
        # that's all we query for, in fact) so if something is done in
        # taskwarrior but not in Jira we want to reconcile to the Jira state.
        if self.tw_json["status"] == "completed":
            mods.extend(["status:pending", "end:"])

        return mods

    @property
    def exists_in_tw(self) -> bool:
        return self.tw_json is not None

    @property
    def tw_uuid(self) -> str:
        if not self.tw_json:
            raise Exception("no taskwarrior json! Create and associate tasks first.")

        return self.tw_json["uuid"]

    @property
    def tw_depends(self) -> typing.List[str]:
        if not self.tw_json:
            raise Exception("no taskwarrior json! Create and associate tasks first.")

        return self.tw_json.get("depends", [])

    @property
    def tw_priority(self) -> str | None:
        if not self.tw_json:
            raise Exception("no taskwarrior json! Create and associate tasks first.")

        return self.tw_json.get("priority", None)

    @property
    def tw_project(self) -> str | None:
        if not self.tw_json:
            raise Exception("no taskwarrior json! Create and associate tasks first.")

        return self.tw_json.get("project", None)

    @property
    def tw_due(self) -> str | None:
        if not self.tw_json:
            raise Exception("no taskwarrior json! Create and associate tasks first.")

        return self.tw_json.get("due", None)

    @property
    def tw_tags(self) -> typing.List[str]:
        if not self.tw_json:
            raise Exception("no taskwarrior json! Create and associate tasks first.")

        return self.tw_json.get("tags", [])


class Fetcher:
    def __init__(self, base: str, username: str, token: str):
        self.base = base
        self.username = username
        self.token = token

    def __get(self, path):
        jira_url = f"{self.base}/{path}"

        # Encode credentials
        credentials = f'{self.username}:{self.token}'
        encoded_credentials = base64.b64encode(credentials.encode('utf-8')).decode('utf-8')

        # Setup request
        request = urllib.request.Request(jira_url)
        request.add_header('Authorization', f'Basic {encoded_credentials}')
        request.add_header('Content-Type', 'application/json')

        with urllib.request.urlopen(request) as response:
            data = response.read()
            return json.loads(data)

    def search(self, query: str) -> typing.List[Issue]:
        encoded_jql = urllib.parse.quote(query)

        tasks = self.__get(f"/rest/api/2/search?jql={encoded_jql}")
        return [Issue(blob) for blob in tasks["issues"]]

    def issue(self, id: str) -> Issue:
        return Issue(self.__get(f"/rest/api/2/issue/{id}"))


class Main:
    def __init__(self, fetcher: Fetcher):
        self.fetcher = fetcher
        self.issues = {}

    def eprint(self, *args, **kwargs):
        print(*args, **kwargs, file=sys.stderr)

    def fetch_assigned_and_open_issues(self):
        self.eprint("fetching assigned and open issues")
        self.issues = {
            issue.key: issue
            for issue in
            self.fetcher.search('assignee = currentUser() AND status != "Closed" AND status != "Resolved" AND status != "Done"')
        }

    def backfill_parent_issues(self):
        """backfill any parent issues that aren't assigned to the current user"""
        backfilled = False
        while not backfilled:
            backfilled = True

            for issue in list(self.issues.values()):
                if issue.parent and issue.parent.key not in self.issues:
                    new_issue = self.fetcher.issue(issue.parent.key)
                    self.eprint(f"backfilling {new_issue.key}")
                    self.issues[new_issue.key] = new_issue
                    backfilled = False

    def associate_ids_from_taskwarrior(self):
        """associate existing UUIDs from taskwarrior"""
        existing = {
            task[JIRA_KEY]: task
            for task in
            json.loads(subprocess.run(["task", "export"], capture_output=True).stdout.decode('utf-8'))
            if JIRA_KEY in task
        }
        for key in set(self.issues).intersection(set(existing)):
            self.issues[key].tw_json = existing[key]

    def create_tasks_for_new_issues(self):
        new_tasks = [
            issue.to_task_json()
            for issue
            in self.issues.values()
            if not issue.exists_in_tw
        ]

        if not new_tasks:
            return

        subprocess.run(
            ["task", "import"],
            input=json.dumps(new_tasks).encode('utf-8')
        )

    def update_task_attributes(self):
        for issue in self.issues.values():
            mods = issue.changes_from_existing_task()
            if mods:
                self.eprint(issue.to_task_json())
                self.eprint(f"updating {issue.key}: {" ".join(mods)}")
                subprocess.run(["task", issue.tw_uuid, 'mod', *mods])

    def update_dependency_relationships(self):
        for issue in self.issues.values():
            hierarchy = [issue]
            while hierarchy[-1].parent:
                hierarchy.append(self.issues[hierarchy[-1].parent.key])

            top_down = list(reversed(hierarchy))
            for (parent, child) in zip(top_down, top_down[1:]):
                if child.tw_uuid not in parent.tw_depends:
                    subprocess.run(["task", parent.tw_uuid, "mod", f"dep:{child.tw_uuid}"])

            inherited_attrs = {}
            for issue in top_down:
                if 'project' not in inherited_attrs and issue.tw_project is not None:
                    inherited_attrs['project'] = issue.tw_project

                if 'priority' not in inherited_attrs and issue.tw_priority is not None:
                    inherited_attrs['priority'] = issue.tw_priority

                if 'due' not in inherited_attrs and issue.tw_due is not None:
                    inherited_attrs['due'] = issue.tw_due

                tags = issue.tw_tags
                if tags:
                    if 'tags' not in inherited_attrs:
                        inherited_attrs['tags'] = []

                    for tag in tags:
                        if tag not in inherited_attrs['tags']:
                            inherited_attrs['tags'].append(tag)

                mods = []
                for k, v in inherited_attrs.items():
                    if k == 'tags':
                        mods.extend(f"+{tag}" for tag in v)
                    else:
                        mods.append(f"{k}:{v}")

                if mods:
                    self.eprint(f"updating {issue.key}: {" ".join(mods)}")
                    subprocess.run(['task', issue.tw_uuid, 'mod', *mods])

    def run(self):
        self.fetch_assigned_and_open_issues()
        self.backfill_parent_issues()

        # get information we already have
        self.associate_ids_from_taskwarrior()

        # create new tasks (that is, ones whose information we don't have
        # already) and then get a full update to get the task bodies
        self.create_tasks_for_new_issues()
        self.associate_ids_from_taskwarrior()

        # we're done setting up! Now we can start reconciling.
        self.update_task_attributes()
        self.update_dependency_relationships()


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("--base", default="https://paynearme.atlassian.net")
    parser.add_argument("--username", default="brian.hicks@paynearme.com")
    parser.add_argument("--token", default=os.environ.get("JIRA_TOKEN", ""))

    args = parser.parse_args()

    Main(Fetcher(args.base, args.username, args.token)).run()
