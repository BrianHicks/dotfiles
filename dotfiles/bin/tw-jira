#!/usr/bin/env python3
import argparse
import base64
from datetime import datetime
import json
import os
import pathlib
import subprocess
import sys
import typing
import urllib.parse
import urllib.request

# UDAs
JIRA_KEY = "jira"
JIRA_STATUS = "jirastatus"
JIRA_PRIORITY = "jirapriority"
JIRA_PARENT = "jiraparent"
JIRA_ISSUE_TYPE = "jiraissuetype"

TW_DATE_FORMAT = "%Y-%m-%dT%H:%M:%SZ"


class TaskwarriorTask:
    def __init__(self, task_json: dict):
        self.json = task_json

    def __contains__(self, k) -> bool:
        return k in self.json

    def __getitem__(self, k) -> str:
        return self.json[k]

    @property
    def uuid(self) -> str:
        return self.json["uuid"]

    @property
    def depends(self) -> typing.List[str]:
        return self.json.get("depends", [])

    @property
    def project(self) -> str | None:
        return self.json.get("project", None)

    @property
    def due(self) -> str | None:
        return self.json.get("due", None)

    @property
    def tags(self) -> typing.List[str]:
        return self.json.get("tags", [])

    @property
    def status(self) -> str:
        return self.json["status"]

    @property
    def entry(self) -> str:
        return self.json["entry"]

    @property
    def entry_dt(self) -> datetime:
        return datetime.strptime(self.entry, "%Y%m%dT%H%M%SZ")


class Issue:
    def __init__(self, issue_json: dict):
        self.json = issue_json
        self.__tw: TaskwarriorTask | None = None

    def __repr__(self):
        return f'<Issue {self.key}>'

    def set_tw(self, tw: TaskwarriorTask):
        self.__tw = tw

    def tw(self) -> TaskwarriorTask:
        if not self.__tw:
            raise Exception("task not set. Associate first!")

        return self.__tw

    @property
    def key(self) -> str:
        return self.json["key"]

    @property
    def fields(self) -> dict:
        return self.json["fields"]

    @property
    def status(self) -> str:
        return self.fields["status"]["name"]

    @property
    def priority(self) -> str:
        return self.fields["priority"]["name"]

    @property
    def summary(self) -> str:
        return self.fields["summary"]

    @property
    def parent(self) -> typing.Optional['Issue']:
        if "parent" in self.fields and self.fields["parent"]:
            return Issue(self.fields["parent"])
        else:
            return None

    @property
    def issue_type(self) -> str:
        return self.fields["issuetype"]["name"]

    @property
    def created(self) -> str:
        return datetime.fromisoformat(self.fields["created"]).replace(microsecond=0, tzinfo=None).strftime(TW_DATE_FORMAT)

    def to_task_json(self) -> dict:
        out = {
            "description": self.summary,
            JIRA_KEY: self.key,
            JIRA_STATUS: self.status.replace(" ", "-").lower(),
            JIRA_PRIORITY: self.priority.replace(" ", "-").lower(),
            JIRA_ISSUE_TYPE: self.issue_type.replace(" ", "-").lower(),
            "entry": self.created,
        }

        if self.parent:
            out[JIRA_PARENT] = self.parent.key

        return out

    def changes_from_existing_task(self) -> typing.List[str]:
        tw = self.tw()

        mods = []

        for (key, value) in self.to_task_json().items():
            if key == "entry":
                comp = tw.entry_dt.strftime(TW_DATE_FORMAT)
                if value != comp:
                    mods.append(f"{key}:{value}")

            elif key not in tw or tw[key] != value:
                if key == "description":
                    mods.append(value)
                else:
                    mods.append(f"{key}:{value}")

        # we currently just assume that all tasks in Jira are pending (and
        # that's all we query for, in fact) so if something is done in
        # taskwarrior but not in Jira we want to reconcile to the Jira state.
        if tw.status == "completed":
            mods.extend(["status:pending", "end:"])

        return mods

    @property
    def exists_in_tw(self) -> bool:
        return self.tw is not None


class Fetcher:
    def __init__(self, base: str, username: str, token: str):
        self.base = base
        self.username = username
        self.token = token

    def __get(self, path):
        jira_url = f"{self.base}/{path}"

        # Encode credentials
        credentials = f'{self.username}:{self.token}'
        encoded_credentials = base64.b64encode(credentials.encode('utf-8')).decode('utf-8')

        # Setup request
        request = urllib.request.Request(jira_url)
        request.add_header('Authorization', f'Basic {encoded_credentials}')
        request.add_header('Content-Type', 'application/json')

        with urllib.request.urlopen(request) as response:
            data = response.read()
            return json.loads(data)

    def search(self, query: str) -> typing.List[Issue]:
        encoded_jql = urllib.parse.quote(query)

        tasks = self.__get(f"/rest/api/2/search?jql={encoded_jql}")
        return [Issue(blob) for blob in tasks["issues"]]

    def issue(self, id: str) -> Issue:
        return Issue(self.__get(f"/rest/api/2/issue/{id}"))


class Main:
    def __init__(self, fetcher: Fetcher):
        self.fetcher = fetcher
        self.issues: typing.Dict[str, Issue] = {}

    def eprint(self, *args, **kwargs):
        print(*args, **kwargs, file=sys.stderr)

    def fetch_assigned_and_open_issues(self):
        self.eprint("fetching assigned and open issues")
        self.issues = {
            issue.key: issue
            for issue in
            self.fetcher.search('assignee = currentUser() AND status != "Closed" AND status != "Resolved" AND status != "Done"')
        }

    def backfill_parent_issues(self):
        """backfill any parent issues that aren't assigned to the current user"""
        backfilled = False
        while not backfilled:
            backfilled = True

            for issue in list(self.issues.values()):
                if issue.parent and issue.parent.key not in self.issues:
                    new_issue = self.fetcher.issue(issue.parent.key)
                    self.eprint(f"backfilling {new_issue.key}")
                    self.issues[new_issue.key] = new_issue
                    backfilled = False

    def associate_ids_from_taskwarrior(self):
        """associate existing UUIDs from taskwarrior"""
        tasks_by_jira_key = {
            task[JIRA_KEY]: TaskwarriorTask(task)
            for task in
            json.loads(subprocess.run(["task", "export"], capture_output=True).stdout.decode('utf-8'))
            if JIRA_KEY in task
        }
        for key in set(self.issues).intersection(set(tasks_by_jira_key)):
            self.issues[key].set_tw(tasks_by_jira_key[key])

    def create_tasks_for_new_issues(self):
        new_tasks = [
            issue.to_task_json()
            for issue
            in self.issues.values()
            if not issue.exists_in_tw
        ]

        if not new_tasks:
            return

        subprocess.run(
            ["task", "import"],
            input=json.dumps(new_tasks).encode('utf-8')
        )

    def update_task_attributes(self):
        for issue in self.issues.values():
            mods = issue.changes_from_existing_task()
            if mods:
                self.eprint(f"updating {issue.key}: {" ".join(mods)}")
                subprocess.run(["task", issue.tw().uuid, 'mod', *mods])

    def update_dependency_relationships(self):
        for issue in self.issues.values():
            hierarchy = [issue]
            while hierarchy[-1].parent:
                hierarchy.append(self.issues[hierarchy[-1].parent.key])

            top_down = list(reversed(hierarchy))
            for (parent, child) in zip(top_down, top_down[1:]):
                if child.tw().uuid not in parent.tw().depends:
                    subprocess.run(["task", parent.tw().uuid, "mod", f"dep:{child.tw().uuid}"])

            self.__inherit_attrs(top_down)

    def __inherit_attrs(self, hierarchy: typing.List[Issue]):
        inherited_attrs: dict[str, str] = {}
        inherited_tags: list[str] = []
        for issue in hierarchy:
            tw = issue.tw()

            if 'project' not in inherited_attrs and tw.project is not None:
                inherited_attrs['project'] = tw.project

            if 'due' not in inherited_attrs and tw.due is not None:
                inherited_attrs['due'] = tw.due

            for tag in issue.tw().tags:
                if tag not in inherited_tags:
                    inherited_tags.append(tag)

            mods: list[str] = []
            for k, v in inherited_attrs.items():
                if k == 'tags':
                    mods.extend(f"+{tag}" for tag in v)
                else:
                    mods.append(f"{k}:{v}")

            mods.extend(inherited_tags)

            if mods:
                self.eprint(f"updating {issue.key}: {" ".join(mods)}")
                subprocess.run(['task', issue.tw().uuid, 'mod', *mods])

    def run(self):
        self.fetch_assigned_and_open_issues()
        self.backfill_parent_issues()

        # get information we already have
        self.associate_ids_from_taskwarrior()

        # create new tasks (that is, ones whose information we don't have
        # already) and then get a full update to get the task bodies
        self.create_tasks_for_new_issues()
        self.associate_ids_from_taskwarrior()

        # we're done setting up! Now we can start reconciling.
        self.update_task_attributes()
        self.update_dependency_relationships()


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("--base", default="https://paynearme.atlassian.net")
    parser.add_argument("--username", default="brian.hicks@paynearme.com")
    parser.add_argument("--token", default=os.environ.get("JIRA_TOKEN", ""))

    args = parser.parse_args()

    if not args.token:
        try:
            with open(os.path.join(pathlib.Path.home(), ".config", "tw-jira-config")) as fh:
                args.token = fh.read().strip()
        except IOError as err:
            print("I couldn't find a Jira token in --token, JIRA_TOKEN, or in the path listed in the error below. Populate one of those and try again!", file=sys.stderr)
            print(file=sys.stderr)
            print(err, file=sys.stderr)
            sys.exit(1)

    Main(Fetcher(args.base, args.username, args.token)).run()
